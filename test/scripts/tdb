#!/usr/bin/env ruby

require 'optparse'
require 'ostruct'

###
### TdbObject
###
class TdbObject

  # Constructor
  def initialize(name, parent = nil)
    @name = name ; @parent = parent ; @parametersArray = [] ; @attributesArray = []
  end

  # Name, parent
  def name() @name end
  def parent() @parent end

  # Parameters
  def parameters() (@parent.nil? ? [] : @parent.parameters).concat(@parametersArray) end
  def get_parameter(index) parameters()[index] end
  def add_parameter(key, value) @parametersArray.push([key, value]) end

  # Attributes
  def attributes() (@parent.nil? ? [] : @parent.attributes).concat(@attributesArray) end
  def get_attribute(index) attributes()[index] end
  def add_attribute(key, value) @attributesArray.push([key, value]) end

  # Inheritable
  def plugin() @plugin || (@parent.nil? ? nil : @parent.plugin) end
  def plugin=(plugin) @plugin = plugin end
  def rights() @rights || (@parent.nil? ? nil : @parent.rights) end
  def rights=(rights) @rights = rights end

end

###
### ArchivalUnit
###
class ArchivalUnit < TdbObject

  # Constructor
  def initialize(name, title, status) super(name, title) ; @status = status end

  # Size, status, title
  def size_in_megabytes() @size_in_megabytes end
  def size_in_megabytes=(sizemb) @size_in_megabytes = sizemb end
  def status() @status end
  def title() parent end

end

###
### Title
###
class Title < TdbObject

  # Constructor
  def initialize(name, publisher) super(name, publisher) end

  # CODEN, ISSN, OCLC, publisher
  def coden() @coden end
  def coden=(coden) @coden = coden end
  def issn() @issn end
  def issn=(issn) @issn = issn end
  def oclc() @oclc end
  def oclc=(coden) @oclc = oclc end
  def publisher() parent end

end

###
### Publisher
###
class Publisher < TdbObject

  # Constructor
  def initialize(name) super(name, nil) end

end

###
### Output
###
class Output

  # Abstract: produce_output
  def produce_output(tdb) raise 'produce_output unimplemented' end

end

###
### XmlOutput
###
class XmlOutput < Output

  # Constructor
  def initialize(complete = false, title_sets = false)
    @complete = complete ; @title_sets = title_sets
  end

  # Concrete: produce_output
  def produce_output(tdb)
    if @complete
      puts '<?xml version="1.0" encoding="UTF-8"?>'
      puts '<!DOCTYPE lockss-config ['
      File.open("#{File.dirname($0)}/../../src/org/lockss/config/lockss-config.dtd") do |file|
        file.each_line {|line| puts line }
      end
      puts ']>'
      blank_line
      puts '<lockss-config>'
      blank_line

      if @title_sets
        begin_property(1, 'org.lockss.titleSet')
        blank_line
        
        librarian_sort(tdb.publishers).each do |publisher|
          begin_property(2, publisher.name)
          property(3, 'name', "All #{escape(publisher.name)} Titles")
          property(3, 'class', 'xpath')
          property(3, 'xpath', "[attributes/publisher='#{escape(publisher.name).gsub(/'/, '&apos;')}']")
          end_property(2)
          blank_line
        end

        end_property(1)
        blank_line
      end

      begin_property(1, 'org.lockss.title')
      blank_line
    end

    librarian_sort(tdb.aus).each do |au|
      next unless $options[:level][au.status]
      begin_property(2, escape(au.name))
      property(3, 'attributes.publisher', escape(au.title.publisher.name))
      property(3, 'issn', au.title.issn) unless au.title.issn.nil?
      property(3, 'journalTitle', escape(au.title.name))
      property(3, 'title', escape(au.name) + case au.status
                                             when :pre_releasing, :pre_released : ' (pre-released)'
                                             when :superseded : ' (superseded)'
                                             else ''
                                             end)
      property(3, 'plugin', au.plugin)
      au.parameters.concat(case au.status
                           when :down, :superseded : [['pub_down', 'true']]
                           else []
                           end).each_index do |index|
        pair = au.get_parameter(index)
        begin_property(3, "param.#{index + 1}")
        property(4, 'key', pair[0])
        property(4, 'value', pair[1])
        end_property(3)
      end
      au.attributes.each {|pair| property(3, "attributes.#{pair[0]}", pair[1]) }
      property(3, 'attributes.rights', 'openaccess') if au.rights == :open_access
      property(3, 'estSize', au.size_in_megabytes) unless au.size_in_megabytes.nil?
      case au.status when :pre_releasing, :pre_released : property(3, 'attributes.releaseStatus', 'pre-release') end
      end_property(2)
      blank_line
    end
  
    if @complete
     end_property(1)
     blank_line
     puts '</lockss-config>'
    end
  end

  # XML output
  def begin_property(n, name) puts "#{indent(n)}<property name=\"#{name}\">" end
  def end_property(n) puts "#{indent(n)}</property>" end
  def property(n, name, value) puts "#{indent(n)}<property name=\"#{name}\" value=\"#{value}\" />" end
  def blank_line() puts '' end

  # XML utilities
  def indent(n) ' ' * n end
  def escape(str) str.gsub(/&/, '&amp;').gsub(/</, '&lt;').gsub(/>/, '&gt;') end

end

###
### MediaWikiListOutput
###
class MediaWikiListOutput < Output

  # Constructor
  def initialize(alternative = false) @alternative = alternative end

  # Concrete: produce_output
  def produce_output(tdb)
    current = ''
    librarian_sort(tdb.publishers).each do |publisher|
      initial = librarian_name(publisher.name)[0, 1].upcase
      if current != initial
        current = initial
        puts "{{Anchor|#{initial}}}{{Big|#{initial}}}" unless @alternative
        puts "{{Anchor|#{initial}}}" if @alternative
      end
      puts "* [[#{publisher.name}]]" unless @alternative
      puts "{{IncludePublisherPage|#{publisher.name}}}" if @alternative
    end
  end

end

###
### Main
###
class Main

  # Big command line options parsing function (on ARGV)
  def parse_command_line
    opts = OptionParser.new
    opts.on("Show debugging output", '-d', '--debug') { $options[:debug] = true }
    opts.on("Show exceptions", '-e', '--exceptions') { $options[:exceptions] = true }
    opts.on("Show usage message", '-h', '-u', '--help', '--usage') { puts opts }
    opts.on("Output level",
            '-lLEVEL', '-l LEVEL', '--level=LEVEL', '--level LEVEL') do |level|
      $options[:level] ||= {}
      level.split(/,/).each {|str| translate_level(str).each {|sym| $options[:level][sym] = true } }
    end
    opts.on("Be quiet", '-q', '--quiet') { $options[:quiet] = true }
    opts.on("Output style",
            '-sSTYLE', '-s STYLE', '--style=STYLE', '--style STYLE',
            [ :mediawiki_publisher,
              :mediawiki_publisher_list,
              :mediawiki_publisher_list_2,
              :xml,
              :xml_entries,
              :xml_legacy ]
            ) {|style| $options[:style] = style }
    opts.on("Show trace", '-t', '--trace') { $options[:trace] = true }

    opts.parse!(ARGV)
  end

  # Processes one @formatString directive
  def process_format_string(line)
    warn "debug: format string" if $options[:debug]
    warn "trace: #{line}" if $options[:trace]

    $indexOf = {}
    $valueOf = {}
    $tdb.delete_field(:_current_publisher)
    $tdb.delete_field(:_current_title)

    (codes = line.split(/\t/)[2].split(/,/)).each_index do |i|
      case codes[i]
      when '@' then
        $indexOf[:attributes] ||= []
        $indexOf[:attributes].push(i)
      when '%' then
        $indexOf[:parameters] ||= []
        $indexOf[:parameters].push(i)
      when 'e' : $indexOf[:size] = i
      when 'p' : $indexOf[:plugin] = i
      when 'R' : $indexOf[:rights] = i
      when 'S' : $indexOf[:status] = i
      when 't' : $indexOf[:name] = i
      when 'x', 'X': nil
      else warn "Illegal format code: #{codes[i]}" unless $options[:quiet]
      end
    end
  end

  # Processes one @fixedValues directive
  def process_fixed_values(line)
    warn "debug: fixed values" if $options[:debug]
    warn "trace: #{line}" if $options[:trace]
    pairs = line.split(/\t/).reject {|elem| elem == '' }
    pairs.shift ; pairs.shift
    title_hint = false
    publisher_hint = false
    pairs.each do |pair|
      key, value = pair.split('=', 2)
      case key
      when 'c' : $valueOf[:coden] = value
      when 'i' : $valueOf[:issn] = value
      when 'j' : $valueOf[:title] = value ; title_hint = true
      when 'o' : $valueOf[:oclc] = value
      when 'p' : $valueOf[:plugin] = value
      when 'P' : $valueOf[:publisher] = value ; publisher_hint = true
      else warn "Illegal fixed value code: #{key}" unless $options[:quiet]
      end
    end
    if (publisher_hint && !$tdb.publishers.detect {|x| x.name == $valueOf[:publisher] })
      publisher = Publisher.new($valueOf[:publisher])
      publisher.plugin = $valueOf[:plugin] unless $valueOf[:plugin].nil?
      $tdb.publishers.push(publisher)
      $tdb._current_publisher = publisher
      $tdb.delete_field(:_current_title)
    end
    if (title_hint && !$tdb.titles.detect {|x| x.name == $valueOf[:title] })
      title = Title.new($valueOf[:title], $tdb._current_publisher)
      title.coden = $valueOf[:coden] unless $valueOf[:coden].nil?
      title.issn = $valueOf[:issn] unless $valueOf[:issn].nil?
      title.oclc = $valueOf[:oclc] unless $valueOf[:oclc].nil?
      title.plugin = $valueOf[:plugin] unless $valueOf[:plugin].nil?
      $tdb.titles.push(title)
      $tdb._current_title = title
    end
  end

  # Processes one AU line
  def process_one_archival_unit(line)
    warn "debug: archival unit" if $options[:debug]
    warn "trace: #{line}" if $options[:trace]
    fields = line.split(/\t/)
    au = ArchivalUnit.new(fields[$indexOf[:name]],
                          $tdb._current_title,
                          fields[$indexOf[:status]].to_sym)
    $indexOf[:parameters].each {|index| au.add_parameter(*fields[index].split(/\=/, 2)) }
    unless $indexOf[:attributes].nil?
      $indexOf[:attributes].each {|index| au.add_attribute(*fields[index].split(/\=/, 2)) }
    end
    au.size_in_megabytes = fields[$indexOf[:size]] unless $indexOf[:size].nil?
    au.plugin = fields[$indexOf[:plugin]] unless $indexOf[:plugin].nil?
    au.rights = fields[$indexOf[:rights]] unless $indexOf[:rights].nil?
    $tdb.aus.push(au)
  end

  # Processes one line from the input file
  def process_one_line(line)
    case line
    when /^\s*$/ :             warn "debug: blank line" if $options[:debug]
    when /^#\t@formatString/ : process_format_string(line)
    when /^#\t@fixedValues/ :  process_fixed_values(line)
    when /^#/ :                warn "debug: comment" if $options[:debug]
    else                       process_one_archival_unit(line)
    end
  end

  # Processes one input file
  def process_one_file(arg)
    warn "debug: begin process_one_file(#{arg})" if $options[:debug]
    File.open(arg) {|file| file.each_line {|line| process_one_line(line.chomp) } }
  rescue => exc
    warn "debug: rescue process_one_file(#{arg})" if $options[:debug]
    warn "exception: #{exc}" if $options[:exceptions]
  end

  # Output dispatcher
  def produce_output
    output = case $options[:style]
             when :xml_entries : XmlOutput.new
             when :xml_legacy : XmlOutput.new(true)
             when :xml : XmlOutput.new(true, true)
             when :mediawiki_publisher_list : MediaWikiListOutput.new
             when :mediawiki_publisher_list_2 : MediaWikiListOutput.new(true)
             when :mediawiki_publisher
               warn "Unimplemented output style: #{$options[:style].to_s}"
               nil
             else
               warn "Unknown output style: #{$options[:style].to_s}" unless $options[:quiet]
               nil
             end
    output.produce_output($tdb)
  end

  # Main program
  def run
    parse_command_line()
    warn "debug: debugging on" if $options[:debug]
    warn "exception: exceptions on" if $options[:exceptions]
    warn "trace: tracing on" if $options[:trace]
    ARGV.each {|arg| process_one_file(arg) }
    produce_output()
#$tdb.aus[0].parameters.each {|a| puts "#{a[0]}=#{a[1]}" }
  end

end

# Translates a level or level synonym (as a string)
# into an array of corresponding levels (as symbols).
def translate_level(str)
  case str.to_sym
  when :production : [ :retracted, :superseded, :down, :released ]
  when :testing : translate_level(:production.to_s).concat([ :releasing, :pre_released,
                      :pre_releasing, :ready, :testing, :manifest, :exists ])
  when :dangerous : translate_level(:testing.to_s).concat([ :do_not_process ])
  when :very_dangerous : translate_level(:dangerous.to_s).concat([ :does_not_exist ])
  when :retracted, :superseded, :down, :released, :releasing, :pre_released, :pre_releasing,
           :ready, :testing, :manifest, :exists, :do_not_process, :does_not_exist : [ str.to_sym ]
  else warn "Unknown level: #{str}" unless $options[:quiet] ; []
  end
end

def librarian_name(str)
  str.downcase.sub(/^(the|an?)\s+/, '').gsub(/\W/, '')
end

def librarian_compare(tdbo1, tdbo2)
  parents = tdbo1.parent.nil? ? 0 : librarian_compare(tdbo1.parent, tdbo2.parent)
  if parents == 0
    librarian_name(tdbo1.name) <=> librarian_name(tdbo2.name)
  else
    parents
  end
end

def librarian_sort(array)
  array.sort {|tdbo1, tdbo2| librarian_compare(tdbo1, tdbo2) }
end

#
# Globals
#

$options = {            # Command line options hash 
  :debug => false,
  :exceptions => false,
  :level => translate_level(:production.to_s).inject({}) {|h, l| h[l] = true ; h },
  :quiet => false,
  :style => :xml_entries,
  :trace => false,
}
$tdb = OpenStruct.new({ # Title database
  :aus => [],
  :publishers => [],
  :titles => [],
})
$indexOf = {}           # Global index helper (explicit)
$valueOf = {}           # Global value helper (implicit)

###
###
###
main = Main.new
main.run


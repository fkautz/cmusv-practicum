#!/usr/bin/python
#
# Wrapper script for ANT plugin packaging and signing tasks that will
# prompt for all the required input (unless otherwise supplied on the
# command line)

from sys import argv, exit
from getpass import getpass
from getopt import getopt, GetoptError
from os import path, environ, popen, getcwd

# Constants
BUILD_ONLY = 0
BUILD_AND_SIGN = 1

validArgs = ["help", "nosign", "jar=", "plugin=",
             "alias=", "keystore=", "password="]
args = {}

# Make sure environment variables are set
if not environ.has_key('ANT_HOME'):
    print "ANT_HOME must be defined in your environment."
    exit(1)

if not environ.has_key('PLUGIN_HOME'):
    print "PLUGIN_HOME must be defined in your environment, and must point to the\n" + \
          "top-level project under which the plugin source files can be found\n" + \
          "(i.e., /path/to/lockss-daemon/)"
    exit(1)

# Location of the 'ant' command.
antBin = path.join(environ.get('ANT_HOME'), 'bin', 'ant')
pluginSrc = path.join(environ.get('PLUGIN_HOME'), 'src')

if not path.isdir(pluginSrc):
    print "Unable to find src directory uner PLUGIN_HOME, can't continue."
    exit(1)

# By default, the mode is to build and sign plugins.
mode = BUILD_AND_SIGN

################################################################################
# Function definitions
#
def usage(help):
    """ Print usage information """
    print "Usage: genplugin [--help] [--nosign] [--jar <jarname>] \\\n \
		 [--plugin <plugin>] [--alias <alias>] [--keystore <keystore>] \\\n \
		 [--password <password>]"
    if (help):
	print """
 nosign       Build a plugin jar without signing it.

Used in all cases:
 jar          The name of the JAR file to create.
 plugin       The full path of the plugin class or XML file from the
	      source directory, complete with extension, in the form
	      "path/to/plugin/foo/FooPlugin.class" or
	      "path/to/plugin/foo/FooPlugin.xml" (absolute or relative path).

Only used if --nosign is not set:
 alias        The alias to use when signing the jar.
 keystore     The keystore holding your signing key.
 password     Your signing password.
"""

def common_path(a, b):
    # path.commonprefix is very broken in python.  It works on
    # strings and not path elements, so it thinks that the common
    # prefix of '/foo/bar' and '/foo/baz' is '/foo/ba' (!)  This
    # is a workaround.
    prefix = path.commonprefix([a, b]);
    if  len(prefix) == len(a):
        return prefix
    else:
        lastsep = (prefix.rfind(path.sep)) + 1
        return prefix[0:lastsep]    
    
def get_plugin_info(plugin):
    """ Given an absolute or relative path, return a tuple consisting
    of the plugin path from the source directory on, and the name of
    the plugin file, i.e. given '/path/to/src/foo/bar/BazPlugin.xml',
    return ('foo/bar', 'BazPlugin.xml') """

    pluginSrc = path.join(environ['PLUGIN_HOME'], 'src') + path.sep
    pluginPath = path.abspath(plugin)
    commonPath = common_path(pluginSrc, pluginPath)

    pluginFile = pluginPath[len(commonPath):]

    return path.split(pluginFile)

#
# If any arguments have not been supplied on the command-line,
# prompt for them.
#
def prompt_for_missing_args():
    """ Prompt the user for missing arguments """
    global mode
    
    while not args.has_key("jar") or len(args["jar"]) == 0:
        args["jar"] = raw_input("JAR file: ")

    while not args.has_key("plugin") or len(args["plugin"]) == 0:
        args["plugin"] = raw_input("Plugin class or XML file: ")

    if not path.isfile(args["plugin"]):
        print("Plugin file '%s' does not exist, can't continue" % args["plugin"])
        exit(1)

    if mode == BUILD_AND_SIGN:
        while not args.has_key("alias") or len(args["alias"]) == 0:
            args["alias"] = raw_input("Signing alias: ")

        while not args.has_key("keystore") or len(args["keystore"]) == 0:
            args["keystore"] = raw_input("Signing keystore: ")

        if not path.isfile(args["keystore"]):
            print("Keystore file %s does not exist, can't continue." % args["keystore"]);
            exit(1)

        while not args.has_key("password") or len(args["password"]) == 0:
            args["password"] = getpass("Signing Password: ")

#
# Parse passed-in command-line arguments.
#
def parse_options(argv):
    """ Parse command-line options """
    global mode
    
    if len(argv) == 0:
        print "For help, use the --help option."

    (opts, vals) = getopt(argv, None, validArgs)

    if len(vals) > 0:
        usage(0)
        exit(1)

    for (opt, arg) in opts:
        if opt == "--help":
            usage(1)
            exit()
        elif opt == "--nosign":
            mode = BUILD_ONLY
        elif opt == "--jar":
            args["jar"] = arg
        elif opt == "--plugin":
            args["plugin"] = arg
        elif opt == "--alias":
            args["alias"] = arg
        elif opt == "--password":
            args["password"] = arg
        elif opt == "--keystore":
            args["keystore"] = arg

#
# Search up the tree until the 'build.xml' file is found, and call
# the ANT command.
#
def run_ant(command):
    """ Run ANT, print the output if there is error. """

    child = popen(antBin + " -f " + buildXml + " " + command)
    output = child.read()
    err = child.close()
    if err:
        print "Ant failed.  Output:"
        print output

    return err

#
# Search up the tree until build.xml is found.  If it cannot be found, exit.
#
def find_build_xml():
    path_elements =  getcwd().split("/")

    while len(path_elements) > 1:
        file = "/".join(path_elements) + "/" + "build.xml";
        if path.exists(file) and path.isfile(file):
            print "Using build xml file " + file
            return file
        else:
            path_elements = path_elements[:len(path_elements) - 1]

    # File wasn't found.
    return None

#
# Build jar and optionally sign
#
def gen_plugin():
    """ Generate and sign an plugin JAR"""
    global mode
    
    try:
        (plugin_path, plugin) = get_plugin_info(args["plugin"])
    except AttributeError:
        print "Error while trying to parse input."
        exit(1)

    print ("Building plugin %s..." % args["jar"])

    command = "build-plugin" + \
              " -Dplugin-jarfile=" + args["jar"] + \
              " -Dplugin-path=" + plugin_path + \
              " -Dplugin-file=" + plugin

    if mode == BUILD_AND_SIGN:
        command = command + \
              " -Dsign-alias=" + args["alias"] + \
              " -Dsign-keystore=" + args["keystore"] + \
              " -Dsign-keypass=\'" + args["password"] + "\'" \
              " -Dsign-storepass=\'" + args["password"] + "\'"

    err = run_ant(command)
    if not err:
        if mode == BUILD_ONLY:
            print "Plugin %s created successfully." % args["jar"]
        else:
            print "Plugin %s created and signed successfully." % args["jar"]

def main():
    """ Main entry point """
    global mode
    global buildXml

    buildXml = find_build_xml()

    if not buildXml:
        print "Unable to find build.xml file."
        exit(1)

    # Parse command line options
    try:
        parse_options(argv[1:])
    except GetoptError:
        usage(0)
        exit(1)

    # Get missing input
    try:
        prompt_for_missing_args()
    except SyntaxError:
        print "Problem while parsing input"
        exit(1)
        
    gen_plugin()

#
# Main
#
if __name__ == "__main__":
    try:
        main()
    except (KeyboardInterrupt, EOFError):
        print
        exit(0)
